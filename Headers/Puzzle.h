#ifndef HAS_IOSTREAM
    #include<iostream>
    #include<vector>
    #include<algorithm>  // Mainly For Swapping Puzzle Pieces
    #define HAS_IOSTREAM
#endif
    
#ifndef HAS_OPENCV
    #include<opencv2/core/core.hpp>
    #include<opencv2/highgui/highgui.hpp>
    #include<opencv2/imgproc/imgproc.hpp>
    #define HAS_OPENCV
    
#endif    

#ifndef HAS_SIZE
        #define BSIZE 80
        #define SIZE 48    
#endif

#define BLOCKS_PER_ROW() 640/BSIZE
#define BLOCKS_PER_COLUMN() 480/BSIZE

#include<random>




/* 
   WE USE A RANDOM FUNCTION GENERATOR
   FROM C++ STANDARD LIBRARY
   TO GENERATE RANDOM NUMBERS

   WE WANT TO SWITCH IT IN A SEQUENCE
   SO WE DONT WANT NUMBERS TO GET REPEATED
   SO WE TAKE ONE HALF AS SEQUENTIAL
   AND OTHER HALF AS RANDOM
   SO THAT WHEN ONE HALF GETS SWAPPED
   THE SEQUENTIAL HALF DOESNT GET SWITCHED AGAIN
   EXAMPLE I CAN SWITCH FROM 0 TO 24 PIECE 
   WITH ANY RANDOM NUMBER FROM 24 TO 47
   I.E THE OTHER 24 PARTS
   BECAUSE
   IF SOMEHOW WE GET SAME NUMBER LIKE 0 OR 0
   OR PREVIOUSLY SWITCHED INDEX, LIKE SAY 3 OR 4
   WHEN SWITCHING WITH 5
   THIS ENSURES MINIMUM PRE-CORRECT PUZZLE LOCATIONS
*/   
std::default_random_engine generator;

std::uniform_int_distribution<int> distribution(24,47);

//VARIABLE TO KEEP TRACK OF PUZZLE RECORDS
int records[SIZE];


cv::Mat Puzzle;

bool Assign_Puzzle(char* s,int bwidth,int bheight,int swidth,int sheight,cv::Scalar Color)
{
    cv::Mat image;
    image = cv::imread(s, CV_LOAD_IMAGE_COLOR);   // Read the file
      
    
    if(! image.data )                        // Check for invalid input
    {
        std::cout <<  "Could not open or find the image\n Please Enter A Valid Image Location\n";
        return false;
    }
    else
    {
    
      int i,j,count=0;
      
      cv::resize(image,image,cv::Size(swidth,sheight));
      
      /*Copy Image To Puzzle After Resizing And Drawing Retangles*/
      
            for(i=0;i<sheight;i+=bheight)
            {
                    
                    for(j=0;j<swidth;j+=bwidth)
                    {
                            cv::rectangle(image,
                                          cv::Point(j,i),
                                          cv::Point(j+bwidth,j+bheight),
                                          Color,
                                          8,
                                          0.25,
                                          0);
                                          
                            //KEEP TRACK OF BLOCK ASSIGNMENT 
                            records[count]=count;
                            count++;
            
                    }
            }
        
      
      Puzzle=image.clone();
     
    
    std::cout<<"\n Puzzle Has Been Accepted \n ";
    
    }
    
   return true;
    
}

bool isPuzzleComplete()
{
    for(int i=0;i<48;i++)
    {
            if(records[i]!=i)
            {
              return false;
            }
    
    }

   return true;

}

void Puzzle_Rearrange()
{
  if(Puzzle.empty()!=1)
    {
    
    /* 
       THIS IS MUCH EASIER TO DO SINCE I KNOW HOW MANY DIVISIONS CAN BE MADE
       IN A ROW OR COLUMN
       AS COMPARED TO FINDING LINEAR INDEXES IN GPU
       SO NO ROW OR COLUMN FINDING PROBLEMS
    */
        for(int i=0;i<(SIZE/2);i++)
        {
          
            // ASSUMING THAT THE RECORDS HAVE BEEN SET ALREADY 
            // DURING PUZZLE ASSIGNMENT
            
            int SWAP = distribution(generator); //GET A NUMBER FROM RANDOM NUMBER GENERATOR
            
            /* SWAP THE PUZZLE PIECES
               ONE PIECE IS INDICATED
               BY THE CURRENT ITERATION 
               IN THE LOOP
               NEXT WILL BE GENERATED BY THE RANDOM 
               NUMBER GENERATOR
            */
            cv::Rect temp1((SWAP/BLOCKS_PER_ROW())*BSIZE,
                           (SWAP/BLOCKS_PER_COLUMN())*BSIZE,
                            BSIZE,BSIZE);
            
            cv::Rect temp2((i/BLOCKS_PER_ROW())*BSIZE,
                           (i/BLOCKS_PER_COLUMN())*BSIZE,
                            BSIZE,BSIZE);
                            
            //HOLD THE IMAGE BLOCK LOCATED IN RANDOM INDEX
            //AND SEQUENCE INDEX
            cv::Mat temp_img1(Puzzle(temp1));
            cv::Mat temp_img2(Puzzle(temp2));
            
            /*
               SWAP BOTH PICTURES WITH EACH OTHER
               OPENCV ONLY SUPPORTS copyTo
               ASSIGNMENT
               
            */
            
            temp_img1.copyTo(Puzzle(temp2));
            temp_img2.copyTo(Puzzle(temp1));
            /*
               KEEP A RECORD OF THE CHANGE/SWAP
            */    
                
                records[i]=SWAP;
                records[SWAP]=i;
              
    
        }

    }

}

void Swap_Pieces(int &prev_index,int &new_index,int block_size)
{
  int height=Puzzle.rows;
  int width= Puzzle.cols;        
        
  cv::Mat temp;
  
  /*
    Using This Concept
    
    If I know the number of block points that can be fit in one row,
    Then I can easily calculate The Number Of Rows It takes
    To Reach That Value  
    
    Turns out that in order to find the block we Need To Interchange the Sizes
    
    Number Of Blocks That can fit in to one row = columns/block_size
    Number Of Blocks That can fit in to one column = row/block_size
  */
  
  
  int old_x=(int)( ( prev_index / height ) * ( block_size * block_size ) );
  int old_y=(int)( ( prev_index / width  ) * ( block_size * block_size ) );
  
 
  int new_x= (int)( ( new_index / height ) * ( block_size * block_size ) );
  int new_y= (int)( ( new_index / width  ) * ( block_size * block_size ) );
  
 
  cv::Rect old_block(old_x,old_y,block_size,block_size);
  cv::Rect new_block(new_x,new_y,block_size,block_size);

  cv::Mat temp_old = Puzzle(old_block);
  cv::Mat temp_new = Puzzle(new_block);
  
  temp_old.copyTo( Puzzle(new_block) );
  temp_new.copyTo( Puzzle(old_block) );  


}

void Blend_Puzzle(cv::Mat &pic,float transparency=0.75)
{
    float opacity=1-transparency;
    addWeighted(Puzzle,opacity,pic,transparency,0.0,pic);
}





