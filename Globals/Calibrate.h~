#ifndef HAS_IOSTREAM
    #include<iostream>
    #include<vector>
    #include<algorithm>  // Mainly For Swapping Puzzle Pieces
    #define HAS_IOSTREAM
#endif


#ifndef HAS_OPENCV
    #include<opencv2/core/core.hpp>
    #include<opencv2/highgui/highgui.hpp>
    #include<opencv2/imgproc/imgproc.hpp>
    #define HAS_OPENCV
#endif 

#include<math>

cv::Mat filter(100,100,cv::CV_8UC1);
const int threshold=(int)(0.6*10000);//60% of space 

void make_Filter()
{
int i,j;
  for(i=0;i<100;i++)
  {
    j=100-(int)sqrt(10000-(i*i));
  
  
  
  }





}

int Calibrate_Finger(cv::Mat &img,cv::Mat &prev,
                     int height,int width,int bheight,int bwidth)
{
    int tempx= (int)((width-bwidth)/2); 
    int tempy=(int)((height-bheight)/2);
    int pixel_density;
    cv::Rect trect(tempx,tempy,bwidth,bheight);
    int finger;
    cv::Mat temp_img1,temp_img2;
    
    /*Convert RGB To Gray And use Adaptive Thresholding
      Then Bit-Wise AND THE Images to extract filter
    */
    cv::cvtColor(img(trect),temp_img,cv::COLOR_RGB2GRAY);
    cv::adaptiveThreshold(temp_img,temp_img,1,
                          cv::CV_ADAPTIVE_THRESH_MEAN_C,
                          cv::CV_THRESH_BINARY,
                          5,
                          0);
    
    cv::bitwise_and(temp_image1,prev,temp_image2);
    
    pixel_density=cv::countNonZero(temp_img2);
    
    if(pixel_density<threshold)
    {
    std::cout<<"\nCalibration Successful\n";
    return temp;
    }
}
